const axios = require('axios');

class VulnerabilityScanner {
  constructor(url) {
    this.url = url;
    this.results = {
      url: url,
      timestamp: new Date().toISOString(),
      vulnerabilities: [],
      securityHeaders: {},
      score: 100
    };
  }

  // Scanner les headers de sécurité
  async checkSecurityHeaders() {
    try {
      const response = await axios.get(this.url, { 
        timeout: 5000,
        validateStatus: () => true 
      });

      const headers = response.headers;
  const requiredHeaders = {
  'x-frame-options': 'Protects against clickjacking',
  'x-content-type-options': 'Prevents MIME sniffing',
  'strict-transport-security': 'Enforces HTTPS',
  'content-security-policy': 'Protects against XSS',
  'x-xss-protection': 'Browser XSS protection'
};

      for (let [header, description] of Object.entries(requiredHeaders)) {
        if (headers[header]) {
          this.results.securityHeaders[header] = {
            present: true,
            value: headers[header],
            description: description
          };
        } else {
          this.results.securityHeaders[header] = {
            present: false,
            description: description
          };
          this.results.vulnerabilities.push({
            type: 'Missing Security Header',
            severity: 'Medium',
            header: header,
            description: `${header} header is missing`,
            recommendation: `Add ${header} header`
          });
          this.results.score -= 10;
        }
      }
    } catch (error) {
      console.error('Error checking headers:', error.message);
      throw new Error('Failed to scan URL: ' + error.message);
    }
  }

  // Test SQL Injection 
  async checkSQLInjection() {
    const sqlPayloads = ["'", "1' OR '1'='1", "admin'--", "' OR 1=1--"];
    
    for (let payload of sqlPayloads) {
      try {
        const testUrl = `${this.url}?id=${payload}`;
        const response = await axios.get(testUrl, { 
          timeout: 3000,
          validateStatus: () => true
        });

       
        const body = response.data.toString().toLowerCase();
        const sqlErrors = ['sql syntax', 'mysql', 'sqlite', 'postgresql', 'ora-', 'syntax error'];
        
        for (let error of sqlErrors) {
          if (body.includes(error)) {
            this.results.vulnerabilities.push({
              type: 'SQL Injection',
              severity: 'Critical',
              payload: payload,
              description: 'Possible SQL injection vulnerability detected',
              recommendation: 'Use prepared statements and input validation'
            });
            this.results.score -= 30;
            return; 
          }
        }
      } catch (error) {
      }
    }
  }

  // Test XSS
  async checkXSS() {
    const xssPayloads = ['<script>alert(1)</script>', '<img src=x onerror=alert(1)>'];
    
    for (let payload of xssPayloads) {
      try {
        const testUrl = `${this.url}?q=${encodeURIComponent(payload)}`;
        const response = await axios.get(testUrl, { 
          timeout: 3000,
          validateStatus: () => true
        });

        const body = response.data.toString();
        
      
        if (body.includes(payload)) {
          this.results.vulnerabilities.push({
            type: 'Cross-Site Scripting (XSS)',
            severity: 'High',
            payload: payload,
            description: 'Possible XSS vulnerability - user input reflected without sanitization',
            recommendation: 'Sanitize and encode all user inputs'
          });
          this.results.score -= 25;
          return;
        }
      } catch (error) {
       
      }
    }
  }

  
  async scan() {
    console.log(` Scanning ${this.url}...`);
    
    await this.checkSecurityHeaders();
    await this.checkSQLInjection();
    await this.checkXSS();

    
    this.results.score = Math.max(0, this.results.score);
    
    console.log(` Scan complete. Score: ${this.results.score}/100`);
    return this.results;
  }
}

module.exports = VulnerabilityScanner;